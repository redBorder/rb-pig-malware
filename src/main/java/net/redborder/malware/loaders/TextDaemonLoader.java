/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 *  Copyright 2013 Endgame Inc.
 *
 */


package net.redborder.malware.loaders;

import net.redborder.malware.util.logger.RbLogger;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.IOUtils;
import org.apache.hadoop.io.Text;
import org.apache.pig.data.Tuple;

import java.io.*;
import java.net.*;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;


/**
 * Hello world!
 */
public class TextDaemonLoader extends AbstractFileDroppingLoader {
    SocketAddress endpoint;

    Socket sock = null;
    BufferedReader in = null;
    OutputStream out = null;
    Logger log = null;

    public TextDaemonLoader(String port) {
        super();
        endpoint = new InetSocketAddress("127.0.0.1", Integer.parseInt(port));
        log = RbLogger.getLogger(TextDaemonLoader.class.getName());
    }

    public TextDaemonLoader(String port, String timeoutMS) {
        super(timeoutMS);
        endpoint = new InetSocketAddress("127.0.0.1", Integer.parseInt(port));
        log = RbLogger.getLogger(TextDaemonLoader.class.getName());
    }

    public TextDaemonLoader(String port, String timeoutMS, String useDevShm) {
        super(timeoutMS, useDevShm);
        endpoint = new InetSocketAddress("127.0.0.1", Integer.parseInt(port));
        log = RbLogger.getLogger(TextDaemonLoader.class.getName());
    }

    @Override
    public void init() throws IOException {
        super.init();
        sock = new Socket();
        if (getTimeoutMS() < (long) Integer.MAX_VALUE) {
            sock.setSoTimeout((int) getTimeoutMS());
        }
        log.info("Connecting to " + endpoint + " ...");
        sock.connect(endpoint);
        out = sock.getOutputStream();
        in = new BufferedReader(new InputStreamReader(sock.getInputStream()));
    }

    @Override
    public Tuple processFile(Text key, BytesWritable value, File binaryFile) throws IOException {

        if (isNeedToAnalize(key.toString())) {
            boolean timedOut = false;
            String result = "";
            Map<String, Object> map = new HashMap<>();

            try {
                out.write((binaryFile.getAbsolutePath() + "\n").getBytes());
                String data = in.readLine();
                if (data != null) {
                    result = data;
                    map.put("md5", key.toString());
                    map.put("malware", result);
                    map.put("toAnalize", false);
                } else {
                    map.put("md5", key.toString());
                    map.put("malware", "clean");
                    map.put("toAnalize", true);
                }
            } catch (SocketTimeoutException e) {
                log.warning("WARN: Exception occurred, attempting to re-connect...");
            } catch (SocketException e) {
                log.severe("WARN: Exception occurred, attempting to re-connect...");
                e.printStackTrace();
                close();
                init();
                out.write((binaryFile.getAbsolutePath() + "\n").getBytes());
                String data = in.readLine();
                getProtoTuple().clear();

                if (data != null) {
                    result = data;
                    map.put("md5", key.toString());
                    map.put("malware", result);
                    map.put("toAnalize", 10);
                } else {
                    map.put("md5", key.toString());
                    map.put("malware", "clean");
                    map.put("toAnalize", 5);
                }
            }
            getProtoTuple().add(map);
            addMalwareCache(key.toString(), map);
        } else {
            getProtoTuple().clear();
        }

        return getTupleFactory().newTuple(getProtoTuple());
    }

    private void close() {
        IOUtils.closeSocket(sock);
        IOUtils.closeStream(in);
        IOUtils.closeStream(out);
    }

    @Override
    public void cleanUp() {
        super.cleanUp();
        close();
    }
}
