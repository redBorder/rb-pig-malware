package net.redborder.malware.loaders.ssdeep;

import net.redborder.malware.util.aerospike.AeroSpikeManager;
import org.apache.commons.lang.StringUtils;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.pig.EvalFunc;
import org.apache.pig.data.Tuple;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


public class Ssdeep extends EvalFunc<Map> {


    String SHA256;
    String ssdeep;
    String hdfs;
    Map<String, Object> map;
    Map<String, Object> relations;
    Long score_compared;
    Long score_torefresh;
    String zkHosts;
    int SIMILARITY_THRESHOLD = 98;


    public Map exec(Tuple input) throws IOException {
        map = new HashMap<>();
        relations = new HashMap<>();
        int similarity;
        SHA256 = (String) input.get(0);
        ssdeep = (String) input.get(1);
        hdfs = (String) input.get(2);
        zkHosts = (String) input.get(3);
        map.put("sha256", SHA256);
        List<Object> data = new ArrayList<>();
        System.out.println("Analyzing: " + SHA256);
        System.out.println("With ssdeep: "+ssdeep);

        if (isMalware(SHA256)) {
            System.out.println("SHA256: "+ SHA256 +" is malware.");
            Path pt = new Path("hdfs://" + hdfs + "/user/oozie/ssdeep/current/part-r-00000");
            FileSystem fs = FileSystem.get(new Configuration());
            BufferedReader br = new BufferedReader(new InputStreamReader(fs.open(pt)));
            try {
                String line;
                line = br.readLine();
                while (line != null) {
                    String compared_sha = line.split(",")[0];
                    String hash2 = line.split(",")[1];
                    System.out.println("Comparing with: "+compared_sha);
                    System.out.println("ssdeep compared: "+ hash2);

                    int blockSize1 = Integer.parseInt(ssdeep.substring(0, ssdeep.indexOf(":")));
                    int blockSize2 = Integer.parseInt(hash2.substring(0, hash2.indexOf(":")));
                    String hashpart11 = ssdeep.substring(ssdeep.indexOf(":") + 1, ssdeep.indexOf(":", ssdeep.indexOf(":") + 1));
                    String hashpart12 = ssdeep.substring(ssdeep.indexOf(":", ssdeep.indexOf(":") + 1) + 1);
                    String hashpart21 = hash2.substring(hash2.indexOf(":") + 1, hash2.indexOf(":", hash2.indexOf(":") + 1));
                    String hashpart22 = hash2.substring(hash2.indexOf(":", hash2.indexOf(":") + 1) + 1);


                    FuzzyHash fh1 = new FuzzyHash(blockSize1, hashpart11, hashpart12);
                    FuzzyHash fh2 = new FuzzyHash(blockSize2, hashpart21, hashpart22);
                    
                    similarity = Compare(fh1, fh2);
                    System.out.println("Similarity is: "+similarity);
                    if (similarity > SIMILARITY_THRESHOLD && !compared_sha.equals(SHA256)) {
                        relations.put(compared_sha, similarity);

                        if (!compared_sha.equals(SHA256)) {

                            Map malware = AeroSpikeManager.getInstance().getHash(compared_sha);

                            if (malware != null) {

                                score_torefresh = (Long) malware.get("sb_fuzzy");
                                if (score_torefresh == null){
                                    score_torefresh = 0L;
                                }
                            } else {
                                score_torefresh = 0L;
                            }

                            Map malware2 = AeroSpikeManager.getInstance().getHash(SHA256);

                            if (malware2 != null) {
                                score_compared = (Long) malware2.get("score");
                                if (score_compared == null){
                                    score_compared = 0L;
                                }
                            }else{
                                score_compared = 0L;
                            }
                            System.out.println("Score_torefresh: "+score_torefresh+", score_compare: "+score_compared);
                            if (score_torefresh < score_compared) {
                                relations.put("score", score_compared * similarity / 100);
                            } else {
                                score_compared = 0L;
                            }
                        }
                    }
                    line = br.readLine();
                }
                Map<String, Object> relationsMap = new HashMap<>();
                relationsMap.put("similarity",relations);
                relationsMap.put("ssdeep",ssdeep);
                relationsMap.put("timestamp",System.currentTimeMillis() / 1000);
                data.add(relationsMap);
                map.put("data",data);
                if(relations.isEmpty()){
                    map.clear();
                }
                System.out.println("Return: " + map);
            } finally {
                br.close();
            }
        } else {
            map.clear();
        }


        return map;
    }



    public static final int SPAMSUM_LENGTH = 64;


    public static final int MIN_BLOCKSIZE = 3;


    static char[] eliminateSequences(String string) {
        char[] str = string.toCharArray();
        StringBuffer ret = new StringBuffer();

        for (int i = 3; i < str.length; i++) {
            if (str[i] != str[i - 1] ||
                    str[i] != str[i - 2] ||
                    str[i] != str[i - 3]) {
                ret.append(str[i]);
            }
        }

        return ret.toString().toCharArray();
    }

    static int scoreStrings(char[] s1, char[] s2, int blockSize) {
        int score = 0;
        int len1, len2;

        len1 = s1.length;
        len2 = s2.length;

        if(len1 == 0){
            len1 = 1;
        }
        if(len2 == 0){
            len2 = 1;
        }

        if (len1 > SPAMSUM_LENGTH || len2 > SPAMSUM_LENGTH) {
            return 0;
        }


        score = StringUtils.getLevenshteinDistance(new String(s1), new String(s2));


        score = (score * SPAMSUM_LENGTH) / (len1 + len2);


        score = (100 * score) / 64;


        if (score >= 100) {
            return 0;
        }


        score = 100 - score;


        if (score > blockSize / MIN_BLOCKSIZE * Math.min(len1, len2)) {
            score = blockSize / MIN_BLOCKSIZE * Math.min(len1, len2);
        }
        return score;
    }


    int Compare(FuzzyHash fh1, FuzzyHash fh2) {


        int score = 0;
        char[] s11, s12;
        char[] s21, s22;


        if (fh1.blocksize != fh2.blocksize &&
                fh1.blocksize != fh2.blocksize * 2 &&
                fh2.blocksize != fh1.blocksize * 2) {
            return 0;
        }


        System.out.println("s11 hash: "+ fh1.hash +"s22 hash: "+fh2.hash +"s12 hash: "+ fh1.hash2+"s22 hash: "+ fh2.hash2);

        s11 = eliminateSequences(fh1.hash);
        s21 = eliminateSequences(fh2.hash);

        s12 = eliminateSequences(fh1.hash2);
        s22 = eliminateSequences(fh2.hash2);
        if (fh1.blocksize == fh2.blocksize) {
            int score1, score2;
            score1 = scoreStrings(s11, s21, fh1.blocksize);
            score2 = scoreStrings(s12, s22, fh2.blocksize);

            score = Math.min(score1, score2);
        } else if (fh1.blocksize == fh2.blocksize * 2) {

            score = scoreStrings(s11, s22, fh1.blocksize);
        } else {

            score = scoreStrings(s12, s21, fh2.blocksize);
        }

        return (int) score;
    }


    public boolean isMalware(String md5) {
        Boolean isMalware = false;
        Long score;
        Map malware = AeroSpikeManager.getInstance().getHash(md5);
        if (malware != null) {
            score = (Long) malware.get("score");
            if (score != null && score >= 80L) {
                isMalware = true;
            }
        }
        return isMalware;
    }


}


