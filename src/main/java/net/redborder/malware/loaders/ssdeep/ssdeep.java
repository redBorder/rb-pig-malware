package net.redborder.malware.loaders.ssdeep;


import com.amazonaws.util.json.JSONArray;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.*;
import org.apache.pig.EvalFunc;
import org.apache.pig.data.Tuple;

import java.io.*;
import java.util.HashMap;
import java.util.Map;

public class Ssdeep extends EvalFunc<Map> {

    String SHA256;
    String ssdeep;
    Map<String,Object> map;
    Map<String,Object> relations;
    public Map exec(Tuple input) throws IOException {
        map = new HashMap<>();
        relations = new HashMap<>();
        int score;
        SHA256 = (String) input.get(0);
        ssdeep = (String) input.get(1);
        System.out.println("El SHA256 es: " + SHA256);
        System.out.println("El ssdeep es: " + ssdeep);

        map.put("SHA256",SHA256);
        map.put("ssdeep",ssdeep);
        System.out.println("El SHA256 es: " + SHA256);

        Path pt=new Path("hdfs://rbh5bs0rffk2:8020/user/oozie/ssdeep/current/part-r-00000");
        FileSystem fs = FileSystem.get(new Configuration());
        BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(pt)));
        System.out.println("El HASH a comparar es: "+ssdeep);
        try {
            String line;
            line=br.readLine();
            while (line != null){
                String compared_sha = line.split(",")[0];
                System.out.println("Se estÃ¡ comparando con: "+line.split(",")[1] );
                SpamSumSignature signature1 = new SpamSumSignature(ssdeep);
                SpamSumSignature signature2 = new SpamSumSignature(line.split(",")[1]);
                score = Compare(signature1,signature2);
                if(score > 90){
                    relations.put(compared_sha,score);
                }
                line = br.readLine();
            }

            map.put("similarity", relations);
            JSONArray jsonArray = new JSONArray();
            jsonArray.put(map);

        } finally {
            br.close();
        }

        return map;
    }

    public final int SPAMSUM_LENGTH = 64;

    public final int MIN_BLOCKSIZE = 3;
    public final int ROLLING_WINDOW = 7;


    private RollingState roll_state;



    private class RollingState
    {
        public int[] window;
        public long h1, h2, h3;
        public long n;

        public RollingState()
        {
            window = new int[ROLLING_WINDOW];
            h1 = h2 = h3 = n = 0;
        }
    }


    private long roll_hash(int c)
    {
        roll_state.h2 = (roll_state.h2 - roll_state.h1) & 0xffffffffL;
        roll_state.h2 = (roll_state.h2 + ((ROLLING_WINDOW * c) & 0xffffffffL)) & 0xffffffffL;

        roll_state.h1 = (roll_state.h1 + c) & 0xffffffffL;
        roll_state.h1 = (roll_state.h1 - roll_state.window[(int)(roll_state.n % ROLLING_WINDOW)]) & 0xffffffffL;

        roll_state.window[(int)(roll_state.n % ROLLING_WINDOW)] = c;
        roll_state.n++;


        roll_state.h3 = (roll_state.h3 << 5) & 0xffffffffL;
        roll_state.h3 = (roll_state.h3 ^ ((c) & 0xFF)) & 0xffffffffL;

        return (roll_state.h1 + roll_state.h2 + roll_state.h3) & 0xffffffffL;
    }


    private long roll_reset()
    {
        roll_state = new RollingState();
        return 0;
    }







    private int has_common_substring(byte[] s1, byte[] s2)
    {
        int i, j;
        int num_hashes;
        long[] hashes = new long[SPAMSUM_LENGTH];

        roll_reset();


        for (i = 0; i < s1.length; i++)
        {
            hashes[i] = roll_hash(s1[i]);
        }
        num_hashes = i;

        roll_reset();


        for (i = 0; i < s2.length; i++)
        {
            long h = roll_hash(s2[i]);
            if (i < ROLLING_WINDOW - 1)
            {
                continue;
            }
            for (j = ROLLING_WINDOW - 1; j < num_hashes; j++)
            {
                if (hashes[j] != 0 && hashes[j] == h)
                {

                    if ((s2.length - i - (ROLLING_WINDOW - 1)) >= ROLLING_WINDOW && ArrayCompare(s2, (s2.length - i - (ROLLING_WINDOW - 1)), s1, (s1.length - j - (ROLLING_WINDOW - 1)), ROLLING_WINDOW) == 0)
                    {
                        return 1;
                    }
                }
            }
        }

        return 0;
    }


    private int ArrayCompare(byte[] array1, int idx1, byte[] array2, int idx2, int rollingWindow)
    {
        boolean result = true;

        for (int a = 0; a < rollingWindow; a++)
        {
            if ((a + idx1) > array1.length)
            {
                return 1;
            }

            if ((a + idx2) > array2.length)
            {
                return 2;
            }

            result &= (array1[a + idx1] == array2[a + idx2]);

            if (!result)
            {
                return -1;
            }
        }
        return 0;
    }



    private byte[] eliminate_sequences2(byte[] str)
    {
        byte[] ret;
        int i, j, len;

        len = str.length;
        ret = new byte[len];

        for (i = j = 3; i < len; i++)
        {
            if (str[i] != str[i - 1] || str[i] != str[i - 2] || str[i] != str[i - 3])
            {
                ret[j++] = str[i];
            }
        }
        return ret;
    }

    private long score_strings(byte[] s1, byte[] s2, long block_size)
    {
        long score;
        int len1, len2;
        len1 = s1.length;
        len2 = s2.length;

        if (len1 > SPAMSUM_LENGTH || len2 > SPAMSUM_LENGTH)
        {
            return 0;
        }


        if (has_common_substring(s1, s2) == 0)
        {
            return 0;
        }


        score = edit_distn(s1, len1, s2, len2);

        score = (score * SPAMSUM_LENGTH) / (len1 + len2);



        score = (100 * score) / 64;


        if (score >= 100)
        {
            return 0;
        }


        score = 100 - score;

        if (score > block_size / MIN_BLOCKSIZE * Math.min(len1, len2))
        {
            score = block_size / MIN_BLOCKSIZE * Math.min(len1, len2);
        }
        return score;
    }

    private int edit_distn(byte[] s1, int len1, byte[] s2, int len2)
    {
        return (int)EditDistance.edit_distn(s1, len1, s2, len2);
    }


    public int Compare(SpamSumSignature signature1, SpamSumSignature signature2)
    {
        long block_size1, block_size2;
        long score;
        byte[] s1, s2;
        byte[] s1_1, s1_2;
        byte[] s2_1, s2_2;

        if (null == signature1 || null == signature2)
        {
            return -1;
        }

        block_size1 = signature1.getBlockSize();
        block_size2 = signature2.getBlockSize();

        if (block_size1 != block_size2 && block_size1 != block_size2 * 2 && block_size2 != block_size1 * 2)
        {
            return 0;
        }


        s1 = eliminate_sequences2(signature1.getHashPart1());
        s2 = eliminate_sequences2(signature2.getHashPart1());


        s1_1 = s1;
        s2_1 = s2;


        s1_2 = eliminate_sequences2(signature1.getHashPart2());
        s2_2 = eliminate_sequences2(signature2.getHashPart2());



        if (block_size1 == block_size2)
        {
            long score1, score2;
            score1 = score_strings(s1_1, s2_1, block_size1);
            score2 = score_strings(s1_2, s2_2, block_size2);


            score = Math.max(score1, score2);
        }
        else if (block_size1 == block_size2 * 2)
        {
            score = score_strings(s1_1, s2_2, block_size1);
        }
        else
        {
            score = score_strings(s1_2, s2_1, block_size2);
        }

        return (int)score;
    }


}