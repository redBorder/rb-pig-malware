package net.redborder.malware.loaders.ssdeep;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.amazonaws.util.json.JSONArray;
import org.apache.commons.lang.StringUtils;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.pig.EvalFunc;
import org.apache.pig.data.Tuple;

/**
 * Created by Lito on 2/7/15.
 */
public class Ssdeep extends EvalFunc<Map> {


    String SHA256;
    String ssdeep;
    Map<String,Object> map;
    Map<String,Object> relations;
    public Map exec(Tuple input) throws IOException {
        map = new HashMap<>();
        relations = new HashMap<>();
        int score;
        SHA256 = (String) input.get(0);
        ssdeep = (String) input.get(1);
        System.out.println("El SHA256 es: " + SHA256);
        System.out.println("El ssdeep es: " + ssdeep);

        map.put("SHA256",SHA256);
        map.put("ssdeep",ssdeep);
        System.out.println("El SHA256 es: " + SHA256);

        Path pt=new Path("hdfs://rbh5bs0rffk2:8020/user/oozie/ssdeep/current/part-r-00000");
        FileSystem fs = FileSystem.get(new Configuration());
        BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(pt)));
        System.out.println("El HASH a comparar es: "+ssdeep);
        try {
            String line;
            line=br.readLine();
            while (line != null){
                String compared_sha = line.split(",")[0];
                System.out.println("Se estÃ¡ comparando con: "+line.split(",")[1] );
                String hash2 = line.split(",")[1];


                int blockSize1 = Integer.parseInt(ssdeep.substring(0, ssdeep.indexOf(":")));
                int blockSize2 = Integer.parseInt(hash2.substring(0, hash2.indexOf(":")));
                String hashpart11 =  ssdeep.substring(ssdeep.indexOf(":")+1,ssdeep.indexOf(":",ssdeep.indexOf(":")+1));
                String hashpart12 = ssdeep.substring(ssdeep.indexOf(":",ssdeep.indexOf(":")+1)+1);
                String hashpart21 = hash2.substring(hash2.indexOf(":")+1,hash2.indexOf(":",hash2.indexOf(":")+1));
                String hashpart22 = hash2.substring(hash2.indexOf(":",hash2.indexOf(":")+1)+1);

                System.out.println("Los valores calculados son: "+ blockSize1 + "," + hashpart11 + "," + hashpart12 + "," + blockSize2 + "," + hashpart21 + "," + hashpart22 );

                FuzzyHash fh1 = new FuzzyHash(blockSize1, hashpart11, hashpart12);
                FuzzyHash fh2 = new FuzzyHash(blockSize2, hashpart21, hashpart22);

                score = Compare(fh1,fh2);
                System.out.println("El valor de score es: "+score);
                if(score > 90){
                    relations.put(compared_sha,score);
                }
                line = br.readLine();
            }

            map.put("similarity", relations);
            JSONArray jsonArray = new JSONArray();
            jsonArray.put(map);

        } finally {
            br.close();
        }

        return map;
    }
    public static final int SPAMSUM_LENGTH = 64;


    public static final int MIN_BLOCKSIZE  = 3;




    static char[] eliminateSequences(String string)
    {
        char[] str = string.toCharArray();
        StringBuffer ret = new StringBuffer();

        for (int i=3;i<str.length;i++) {
            if (str[i] != str[i-1] ||
                    str[i] != str[i-2] ||
                    str[i] != str[i-3]) {
                ret.append(str[i]);
            }
        }

        return ret.toString().toCharArray();
    }

    static int scoreStrings(char[] s1, char[] s2, int blockSize)
    {
        int score = 0;
        int len1, len2;

        len1 = s1.length;
        len2 = s2.length;

        if (len1 > SPAMSUM_LENGTH || len2 > SPAMSUM_LENGTH) {
            return 0;
        }




        score = StringUtils.getLevenshteinDistance(new String(s1), new String(s2));


        score = (score * SPAMSUM_LENGTH) / (len1 + len2);



        score = (100 * score) / 64;


        if (score >= 100) {
            return 0;
        }


        score = 100 - score;


        if (score > blockSize/MIN_BLOCKSIZE * Math.min(len1, len2)) {
            score = blockSize/MIN_BLOCKSIZE * Math.min(len1, len2);
        }
        return score;
    }


    int Compare(FuzzyHash fh1, FuzzyHash fh2 )
    {


        int score = 0;
        char[] s11, s12;
        char[] s21, s22;


        if (fh1.blocksize != fh2.blocksize &&
                fh1.blocksize != fh2.blocksize*2 &&
                fh2.blocksize != fh1.blocksize*2) {
            return 0;
        }

        s11 = eliminateSequences(fh1.hash);
        s21 = eliminateSequences(fh2.hash);

        s12 = eliminateSequences(fh1.hash2);
        s22 = eliminateSequences(fh1.hash2);

        if (fh1.blocksize == fh2.blocksize) {
            int score1, score2;
            score1 = scoreStrings(s11, s21, fh1.blocksize);
            score2 = scoreStrings(s12, s22, fh2.blocksize);

            score = Math.min(score1, score2);
        } else if (fh1.blocksize == fh2.blocksize*2) {

            score = scoreStrings(s11, s22, fh1.blocksize);
        } else {

            score = scoreStrings(s12, s21, fh2.blocksize);
        }

        return (int)score;
    }

}


