package net.redborder.malware.loaders.metascan;

import net.redborder.malware.loaders.AbstractFileDroppingLoader;
import net.redborder.malware.util.ConfigFile;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.Text;
import org.apache.pig.data.Tuple;
import org.codehaus.jackson.map.ObjectMapper;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;
import java.net.UnknownHostException;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


public class MetascanOnlineLoader extends AbstractFileDroppingLoader {

    String apiKey;
    ObjectMapper mapper;
    static final String lookupURL = "https://api.metadefender.com/v4/hash/%s";
    static final String scanURL = "https://api.metadefender.com/v4/file";
    static final String scoreName = "fb_metascan";
    Proxy proxy;

    private Proxy configProxy() {
    	
        if (ConfigFile.getInstance().getFromGeneral("proxy_ip") != null && ConfigFile.getInstance().getFromGeneral("proxy_port") != null) {
            String ip = ConfigFile.getInstance().getFromGeneral("proxy_ip");
            int port = ConfigFile.getInstance().getFromGeneral("proxy_port");
            proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(ip, port));
        } else {
            proxy = null;
        }
		return proxy;
    }
    
    public MetascanOnlineLoader(String zkHost, String apiKey) {
        super(zkHost);
        mapper = new ObjectMapper();
        this.apiKey = apiKey;
        System.setProperty("jsse.enableSNIExtension", "false");
        
        proxy = configProxy();
    }

    public MetascanOnlineLoader(String zkHost, String apiKey, String timeoutMS) {
        super(zkHost, timeoutMS);
        mapper = new ObjectMapper();
        this.apiKey = apiKey;
        System.setProperty("jsse.enableSNIExtension", "false");
        proxy = configProxy();
    }

    public MetascanOnlineLoader(String zkHost, String apiKey, String timeoutMS, String useDevShm) {
        super(zkHost, timeoutMS, useDevShm);
        mapper = new ObjectMapper();
        this.apiKey = apiKey;
        System.setProperty("jsse.enableSNIExtension", "false");
        proxy = configProxy();
    }

    private String getMetaScanResponseFromHash(String hash) {
    	
    	//log.info("Getting MetaDefender response from hash");
		
		HttpURLConnection conn;
    	int responseCode;

    	StringBuffer response = new StringBuffer();
    	
    	// Setting https protocols
    	System.setProperty("https.protocols", "TLSv1.1,TLSv1.2,SSLv3,SSLv2Hello");
    	
    	try {
            URL objLookup = new URL(String.format(lookupURL, hash));
            
            conn = (HttpURLConnection) objLookup.openConnection();

            conn.setRequestMethod("GET");
            conn.setRequestProperty("apikey", apiKey);
    	
            responseCode = conn.getResponseCode();
            
            switch (responseCode) {
	            case 400:
	                //log.info("CODE 400 Bad Request - Unsupported HTTP method or invalid HTTP request (e.g., empty body)");
	                break;
	            case 401:
	                //log.info("CODE 401 Invalid API key - Either missing API key or invalid API is passed.");
	                break;
	            case 403:
	                //log.info("CODE 403 Signature lookup limit reached, try again later - The hourly hash lookup limit has been reached for this API key.");
	                break;
	            case 404:
	                //log.info("CODE 404 The requested page was not found. Try to upload the file.");
	            	return response.toString();
	            case 503:
	                //log.info("CODE 503 Internal Server Error - Server temporarily unavailable. Try again later.");
	                break;
	            case 200:
	                //log.info("CODE 200 Petition completed");
	
	                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
	                
	                String inputLine;
	
	                while ((inputLine = bufferedReader.readLine()) != null) {
	                    response.append(inputLine);
	                }
	
	                bufferedReader.close();
            }
    	}
    	catch (java.io.IOException ex)  {}
        catch (NumberFormatException ex){}
    	
    	return response.toString();
	}
	
	private String getMetaScanResponseFromDataID(String dataID) {
		
		//log.info("Getting MetaDefender response from data id");

		// Setting https protocols
    	System.setProperty("https.protocols", "TLSv1.1,TLSv1.2,SSLv3,SSLv2Hello");
		
		HttpURLConnection conn;
    	int responseCode;	
    	int progress = 0; 	
    	BufferedReader bufferedReader;
        Map<String, Object> fileJson;      
        String inputLine;
    	StringBuffer response = null;
    	
    	//Waiting until MetaScan finish the analysis
    	while (progress < 100) {
    		
	    	try {
	            URL objLookup = new URL(String.format(lookupURL, dataID));
	            
	            conn = (HttpURLConnection) objLookup.openConnection();
	
	            conn.setRequestMethod("GET");
	            conn.setRequestProperty("apikey", apiKey);
	            conn.setRequestProperty("x-file-metadata", "1");
	            
	            responseCode = conn.getResponseCode();
	            
	            switch (responseCode) {
		            case 400:
		                //log.info("CODE 400 Bad Request - Unsupported HTTP method or invalid HTTP request (e.g., empty body)");
		                break;
		            case 401:
		                //log.info("CODE 401 Invalid API key - Either missing API key or invalid API is passed.");
		                break;
		            case 403:
		                //log.info("CODE 403 Signature lookup limit reached, try again later - The hourly hash lookup limit has been reached for this API key.");
		                break;
		            case 404:
		            	//log.info("CODE 404 The requested page was not found. Try to upload the file.");
		            	//404 The requested page was not found
		            	return response.toString();
		            case 503:
		                //log.info("CODE 503 Internal Server Error - Server temporarily unavailable. Try again later.");
		                break;
		            case 200:
		                //log.info("CODE 200 Petition completed");
		
		                bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
		
		                response = new StringBuffer();
		                
		                while ((inputLine = bufferedReader.readLine()) != null) {
		                    response.append(inputLine);
		                }
		
		                bufferedReader.close();
		                
		                mapper = new ObjectMapper();
		                
		                fileJson = mapper.readValue(response.toString(), Map.class);
		                Map<String, Object> fileInfo = (Map<String, Object>) fileJson.get("scan_results");
		                progress = (int) fileInfo.get("progress_percentage");
	            }
	    	}
	    	catch (java.io.IOException ex)  {}//log.error(ex.getLocalizedMessage());}
	        catch (NumberFormatException ex){}//log.error(ex.getLocalizedMessage());}
		
    	}
    	return response.toString();
	}
    
	private Map<String, Object> getInfoFromResponse(String response) {
    	
		//log.info("Getting Metascan report");
		
		// Settings
    	System.setProperty("https.protocols", "TLSv1.1,TLSv1.2,SSLv3,SSLv2Hello");
    	System.setProperty("jsse.enableSNIExtension", "false");
    	
		Map<String, Object> data = new HashMap<>();
	                
        mapper = new ObjectMapper();
        
		Map<String, Object> fileJson;
		
		try {
			fileJson = mapper.readValue(response, Map.class);
			
	        data.put("ms_file_id", fileJson.get("file_id"));
	
	        Map<String, Object> fileInfo = (Map<String, Object>) fileJson.get("file_info");
	        data.putAll(fileInfo);
	
	        Map<String, Object> scanResult = (Map<String, Object>) fileJson.get("scan_results");
	        data.put("status", scanResult.get("scan_all_result_a").toString().toLowerCase());
	        data.put("engines_total", scanResult.get("total_avs"));
	
	        Map<String, Object> scans = (Map<String, Object>) scanResult.get("scan_details");
	        List<Map<String, Object>> engines = new ArrayList<>();
	
	        int detected = (int) scanResult.get("total_detected_avs");
	        int total = scans.size();
	        
	        for (String engineName : scans.keySet()) {
	        	Map<String, Object> engine = new HashMap<>();
	        	Map<String, Object> scan = (Map<String, Object>) scans.get(engineName);
	        	String result = scan.get("threat_found").equals("") ? "N/A" : (String) scan.get("threat_found");
	
	            engine.put("engine", engineName);
	            engine.put("result", result);
	            engine.put("version", scan.get("def_time"));
	            engines.add(engine);
	        }
	
		    data.put("score", detected * 100 / total);
		    data.put("engines", engines); 
		}
		catch (JsonParseException ex) 	{}//log.error(ex.getLocalizedMessage());}
		catch (JsonMappingException ex) {}//log.error(ex.getLocalizedMessage());} 
		catch (IOException ex) 			{}//log.error(ex.getLocalizedMessage());}
		
    	return data;
    }
	
	private String sendFileToMetascan(File file) {
    	
		//log.info("Sending File to MetaDefender");
		
		// Settings
    	System.setProperty("https.protocols", "TLSv1.1,TLSv1.2,SSLv3,SSLv2Hello");
		
		HttpsURLConnection conn;
    	int responseCode;
    	ObjectMapper mapper = new ObjectMapper();
    	String data_id = "";
    	String response;  	
    	
    	class TrustEverythingTrustManager implements X509TrustManager {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {return null;}

            public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {}

            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {}
        }

        class VerifyEverythingHostnameVerifier implements HostnameVerifier {
            public boolean verify(String string, SSLSession sslSession) {return true;}
        }

        TrustManager[] trustManager = new TrustManager[]{new TrustEverythingTrustManager()};
        SSLContext sslContext = null;
        try {
            sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustManager, new java.security.SecureRandom());
        } 
        catch (NoSuchAlgorithmException ex) {}//log.error(ex.getLocalizedMessage());} 
        catch (KeyManagementException ex) 	{}//log.error(ex.getLocalizedMessage());}

        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
    	
        // Start Connection
    	try {
            URL objLookup = new URL(scanURL);
            
            conn = (HttpsURLConnection) objLookup.openConnection();
            conn.setRequestMethod("POST");
            conn.setRequestProperty("apikey", apiKey);
            conn.setRequestProperty("Content-Type", "application/octet-stream");
            conn.setHostnameVerifier(new VerifyEverythingHostnameVerifier());
            conn.setDoOutput(true);
         
            DataOutputStream wr = new DataOutputStream(conn.getOutputStream());

            for (byte b : file.toString().getBytes()) {
                wr.writeByte(b);
            }
            
            wr.flush();
            wr.close();

            responseCode = conn.getResponseCode();
            
            switch(responseCode) {
            case 400:
            	return data_id;
            case 200:
            	//The request has succeeded
            	break;
            }
            
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));

            response = bufferedReader.readLine();
            
            Map<String, Object> fileJson = mapper.readValue(response.toString(), Map.class);
            
            data_id = (String) fileJson.get("data_id");
        }
    	catch (java.io.IOException ex)  	{}//log.error(ex.getLocalizedMessage());}
        catch (NumberFormatException ex)	{}//log.error(ex.getLocalizedMessage());}
    	
    	return data_id;
    }
    
    @Override
    public Tuple processFile(Text key, BytesWritable bytesWritable, File file) throws IOException {
    	
        String hash = key.toString();
        
        Map<String, Object> data = getInfoFromResponse(getMetaScanResponseFromHash(hash));

        if (data.isEmpty()) {
        	String dataID = sendFileToMetascan(file);
        	
        	data = getInfoFromResponse(getMetaScanResponseFromDataID(dataID));
        	
        	if (data.isEmpty()) {
        		data.put("malware", "N/A");
        		data.put("score", -1L);
        	}
        }


        try {
            String hostname = InetAddress.getLocalHost().getHostName();
            data.put("sensor_name", hostname);
        } catch (UnknownHostException ex) {}//log.error(ex.getLocalizedMessage());}

        data.put("loader", "metascan");
        data.put("timestamp", System.currentTimeMillis() / 1000);

        Double weight = getWeight(scoreName);
        if (weight != null) {
            data.put("weight", weight);
        }

        String jsonData = mapper.writeValueAsString(data);

        Long score = (Long) data.get("score");
        updateMalwareScore(hash, scoreName, score, LoaderType.FAST);

        getProtoTuple().clear();
        getProtoTuple().add(hash);
        getProtoTuple().add(jsonData);

        return getTupleFactory().newTuple(getProtoTuple());
    }
}
