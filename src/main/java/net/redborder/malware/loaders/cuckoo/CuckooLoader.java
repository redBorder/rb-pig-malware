package net.redborder.malware.loaders.cuckoo;

import net.redborder.malware.loaders.AbstractFileDroppingLoader;
import net.redborder.malware.util.logger.RbLogger;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.Text;
import org.apache.pig.data.Tuple;
import org.codehaus.jackson.map.ObjectMapper;

import java.io.*;
import java.net.*;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

/**
 * Created by andresgomez on 26/1/15.
 */
public class CuckooLoader extends AbstractFileDroppingLoader {

    String CuckooToConnect = " http://127.0.0.1:8090/tasks/create/file";
    String urlToConnect;
    ObjectMapper mapper;
    Integer MAX_RETRIES = 5;
    Logger log;
    String[] cuckoo_instances;

    public CuckooLoader(String url, String instances, String zkHost, String timeout, String useDevShm) {
        this(url, instances, zkHost, "5", timeout, useDevShm);
    }

    public CuckooLoader(String url, String instances, String zkHost, String maxRetries, String timeout, String useDevShm) {
        super(zkHost, timeout, useDevShm);
        MAX_RETRIES = Integer.valueOf(maxRetries);
        mapper = new ObjectMapper();
        log = RbLogger.getLogger(CuckooLoader.class.getName());
        cuckoo_instances = instances.split(",");
        CuckooToConnect = url;
    }

    @Override
    public Tuple processFile(Text key, BytesWritable value, File binaryFile) throws IOException {
        if (isNeedToAnalize(key.toString()) && isCuckooBefore(key.toString()) == 0) {
            for (String instance_tosend : cuckoo_instances) {

                urlToConnect = "http://" + CuckooToConnect + ":8090/tasks/create/file";
                String boundary = Long.toHexString(System.currentTimeMillis()); // Just generate some unique random value.

                boolean next = true;
                int times = 0;

                URLConnection connection = new URL(urlToConnect).openConnection();
                connection.setDoOutput(true); // This sets request method to POST.
                connection.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary);
                PrintWriter writer;
                writer = new PrintWriter(new OutputStreamWriter(connection.getOutputStream(), "UTF-8"));


                while (next) {
                    try {
                        writer.println("--" + boundary);
                        writer.println("Content-Disposition: form-data; name=\"machine\"");
                        writer.println("Content-Type: text/plain; charset=UTF-8");
                        writer.println();
                        writer.println(instance_tosend);

                        writer.println("--" + boundary);
                        writer.println("Content-Disposition: form-data; name=\"file\"; filename=\"" + binaryFile.getName() + "\"");
                        writer.println("Content-Type: text/plain; charset=UTF-8");
                        writer.println();
                        BufferedReader reader = null;
                        try {
                            reader = new BufferedReader(new InputStreamReader(new FileInputStream(binaryFile.getPath()), "UTF-8"));
                            for (String line; (line = reader.readLine()) != null; ) {
                                writer.println(line);
                            }


                        } finally {
                            if (reader != null) try {
                                reader.close();
                            } catch (IOException logOrIgnore) {
                            }
                        }

                        writer.println("--" + boundary + "--");

                    } finally {
                        if (writer != null) writer.close();
                    }

                    if (((HttpURLConnection) connection).getResponseCode() == 200) {
                        next = false;
                    } else {
                        if (times > MAX_RETRIES) {
                            next = false;
                        } else {
                            times++;
                        }
                        try {
                            Thread.sleep(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }

                BufferedReader in = new BufferedReader(
                        new InputStreamReader(connection.getInputStream()));
                String inputLine;
                StringBuffer response = new StringBuffer();

                while ((inputLine = in.readLine()) != null) {
                    response.append(inputLine);
                }
                in.close();

                ((HttpURLConnection) connection).disconnect();

                Map<String, Object> status = (Map<String, Object>) mapper.readValue(response.toString(), Map.class);

                String hostname = "";

                try {
                    hostname = InetAddress.getLocalHost().getHostName();
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }

                Map<String, Object> data = new HashMap<>();
                data.put("sha256", key.toString());
                data.put("malware_name", "Cuckoo-TaskID:" + status.get("task_id"));
                data.put("score", 0);
                data.put("timestamp", System.currentTimeMillis() / 1000);
                data.put("type", "cuckoo");
                data.put("sensor_name", hostname);

                Map<String, Object> toCache = new HashMap<>();
                toCache.put("cuckoo_before", 1);
                toCache.putAll(data);


                getProtoTuple().clear();
                Long score = getScore(key.toString());
                Integer currentScore = (Integer) data.get("score");

                if (score == null || score.intValue() != currentScore) {
                    getProtoTuple().add(data);
                }

                addMalwareCache(key.toString(), data);
            }
        } else {
            getProtoTuple().clear();
        }
        return getTupleFactory().newTuple(getProtoTuple());
    }

}
