package net.redborder.malware.loaders.decompress;

import net.redborder.apache.commons.compress.PasswordRequiredException;
import net.redborder.decompress.UniversalDecompressor;
import net.redborder.decompress.exceptions.UnsupportedFormatException;
import net.redborder.decompress.helpers.FileHelper;
import net.redborder.decompress.models.Archive;
import net.redborder.decompress.models.ArchiveFile;
import net.redborder.malware.loaders.AbstractFileDroppingLoader;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.MRJobConfig;
import org.apache.hadoop.mapreduce.RecordReader;
import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;
import org.apache.pig.data.Tuple;
import org.codehaus.jackson.map.ObjectMapper;
import org.jets3t.service.Jets3tProperties;
import org.jets3t.service.S3Service;
import org.jets3t.service.S3ServiceException;
import org.jets3t.service.impl.rest.httpclient.RestS3Service;
import org.jets3t.service.model.S3Object;
import org.jets3t.service.security.AWSCredentials;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;

public class DecompressLoader extends AbstractFileDroppingLoader{

    ObjectMapper mapper;
    S3Service s3Service;
    private AWSCredentials awsCredentials;

    private final String JETS3T_CONFIG_FILE     = "jets3t.properties";
    private final String DECOMPRESS_CONTROL_BIN = "decompressed";
    private final String DECOMPRESS_SCORE_NAME  = "fb_decompress";

    public DecompressLoader(String zkHost, String timeoutMS, String useDevShm, String awsAcess, String awsSecret) {
        super(zkHost, timeoutMS, useDevShm);
        mapper = new ObjectMapper();
        awsCredentials = new AWSCredentials(awsAcess, awsSecret);
    }

    @Override
    public void prepareToRead(RecordReader reader, PigSplit split) throws IOException {
        super.prepareToRead(reader, split);
        Jets3tProperties properties = new Jets3tProperties();
        try {
            properties.loadAndReplaceProperties(new FileInputStream(new File(JETS3T_CONFIG_FILE)), JETS3T_CONFIG_FILE);
            s3Service = new RestS3Service(awsCredentials, null, null, properties);
        } catch (IOException e){
            e.printStackTrace();
        }
    }

    @Override
    public Tuple processFile(Text key, BytesWritable value, File binaryFile) throws IOException {
        Configuration configuration = new Configuration();
        configuration.setBoolean(MRJobConfig.MAPREDUCE_JOB_USER_CLASSPATH_FIRST, true);

        Map<String, Object> data = new HashMap<>();
        Archive archive = null;

        try {
            archive = UniversalDecompressor.decompress(binaryFile);

            List<Map<String, Object>> fileMaps = new ArrayList<>();
            if (archive != null) {
                for (ArchiveFile file : archive.getFiles()) {
                    file.calculateSha256();
                    // JSON content generation
                    Map<String, Object> fileMap = new HashMap<>();
                    fileMap.put("relative_path", file.getRelativePath());
                    fileMap.put("hash", file.getSha256());
                    fileMap.put("size", file.getContent().length);
                    fileMaps.add(fileMap);
                }
                data.put("files", fileMaps);

                try {
                    String hostname = InetAddress.getLocalHost().getHostName();
                    data.put("sensor_name", hostname);
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }

                data.put("loader", "decompress");
                data.put("timestamp", System.currentTimeMillis() / 1000);
                data.put("compress_type", archive.getCompressionType().getExtension());
                data.put("file_mime_type", archive.getMimeType());

                if (!isRepeated(key.toString())) {
                    for (ArchiveFile file : archive.getFiles()) {
                        // S3 file upload
                        S3Object fileObject = new S3Object();
                        fileObject.setDataInputStream(new ByteArrayInputStream(file.getContent()));
                        fileObject.setKey("/mdata/input/" + file.getSha256());
                        Integer retries = 0;
                        while (retries <= 3) {
                            try {
                                s3Service.putObject("malware", fileObject);
                                retries = 5;
                            } catch (S3ServiceException e) {
                                System.out.println("S3 service exception retry[#" + retries + "]");
                                e.printStackTrace();
                                retries++;
                            }
                        }
                    }
                } else {
                    System.out.println("Skipping " + key + " content upload because it has already been done.");
                }

                updateArchiveScore(archive, key.toString());
            }
        } catch (PasswordRequiredException e) {

            System.out.println("Skipping " + key + " because a password is needed");
            data.put("loader", "decompress");
            data.put("timestamp", System.currentTimeMillis() / 1000);
            data.put("files", Collections.EMPTY_LIST);
            data.put("compress_type", "encrypted " +  FileHelper.fileToCompressionType(binaryFile));
            data.put("file_mime_type", FileHelper.getMimeTypes(binaryFile).toArray()[0]);

            try {
                String hostname  = InetAddress.getLocalHost().getHostName();
                data.put("sensor_name", hostname);
            } catch (UnknownHostException e1) {
                e1.printStackTrace();
            }

        } catch (UnsupportedFormatException e) {

            System.out.println("File " + binaryFile + " is not compressed or not supported");
            data.put("loader", "decompress");
            data.put("timestamp", System.currentTimeMillis() / 1000);
            data.put("files", Collections.EMPTY_LIST);
            data.put("compress_type", "not compressed");
            data.put("file_mime_type", FileHelper.getMimeTypes(binaryFile).toArray()[0]);

            try {
                String hostname  = InetAddress.getLocalHost().getHostName();
                data.put("sensor_name", hostname);
            } catch (UnknownHostException e1) {
                e1.printStackTrace();
            }

        }

        getProtoTuple().clear();
        String json = mapper.writeValueAsString(data);
        getProtoTuple().add(key.toString());
        getProtoTuple().add(json);

        aeroSpikeManager.setControlFile(key.toString(), DECOMPRESS_CONTROL_BIN, 1L);

        return getTupleFactory().newTuple(getProtoTuple());
    }

    public boolean isRepeated(String hash){
        return aeroSpikeManager.checkControlFilesStatus(hash, DECOMPRESS_CONTROL_BIN);
    }

    /* Private methods */

    private Long updateArchiveScore(Archive archive, String hash) {
        Long archiveScore = getArchiveScore(archive);
        aeroSpikeManager.updateMalwareHashScore(hash, DECOMPRESS_SCORE_NAME,
                archiveScore, LoaderType.FAST);

        return archiveScore;
    }

    private Long getArchiveScore(Archive archive){

        Long maxScore = -1L;
        // For each file that belongs to the archive
        for (ArchiveFile file : archive.getFiles()) {
            // Fetch it's score from aerospike
            Map<String, Object> fileInfo = aeroSpikeManager.getHash(file.calculateSha256());
            if (fileInfo != null) {
                // Archive score will be the highest of it's child files
                Long fileScore = (Long) fileInfo.get("score");
                if ( fileScore != null && fileScore > maxScore) {
                    maxScore = fileScore;
                }
            }
        }

        return maxScore;
    }

}
