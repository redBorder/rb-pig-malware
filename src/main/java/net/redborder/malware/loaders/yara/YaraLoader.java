/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 *  Copyright 2013 Endgame Inc.
 *
 */


package net.redborder.malware.loaders.yara;


import net.redborder.malware.loaders.AbstractExecutingLoader;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.RecordReader;
import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;
import org.apache.pig.data.Tuple;
import org.codehaus.jackson.map.ObjectMapper;
import org.ho.yaml.Yaml;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;

public class YaraLoader extends AbstractExecutingLoader {

    private final String YARA_WEIGHTS = "yara_weights.yml";

    private final String HIGH_SEVERITY   = "high";
    private final String MEDIUM_SEVERITY = "medium";
    private final String LOW_SEVERITY    = "low";

    String scoreName = "fb_yara";
    ObjectMapper mapper;

    private Map<String, Object> rawWeights;
    private Map<String, Map<String, Object>> weights;

	public YaraLoader(String zkHosts){
		this(zkHosts, "scripts/pyyara.py", String.valueOf(Long.MAX_VALUE));
	}
	
	public YaraLoader(String zkHosts, String timeoutMS){
		this(zkHosts, timeoutMS, "true");
	}
	
	public YaraLoader(String zkHosts, String timeoutMS, String useDevShm){
		super(zkHosts, "scripts/pyyara.py", timeoutMS, useDevShm);
        mapper = new ObjectMapper();
	}

    @Override
    public void prepareToRead(RecordReader reader, PigSplit split) throws IOException {
        super.prepareToRead(reader, split);
        loadYaraConfig();
    }

    @Override
    public Tuple outputToTuple(Text key, BytesWritable value, String output, boolean timedOut) {
        String hash = key.toString();
        LoaderType loaderType = LoaderType.FAST;

        Map<String, Object> data = process(output);

        data.put("timestamp", System.currentTimeMillis() / 1000);

        Double weight = getWeight(scoreName);
        if (weight != null) {
            data.put("weight", weight);
        }

        try {
            String hostname = InetAddress.getLocalHost().getHostName();
            data.put("sensor_name", hostname);
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }

        String jsonData = "{}";
        try {
            jsonData = mapper.writeValueAsString(data);
        } catch (IOException e) {
            e.printStackTrace();
        }


        Long score = (Long) data.get("score");
        updateMalwareScore(hash, scoreName, score, loaderType);

        getProtoTuple().clear();
        getProtoTuple().add(hash);
        getProtoTuple().add(jsonData);

        return tupleFactory.newTuple(getProtoTuple());
    }

    /* Private methods */

    private Map<String, Object> process(String input){
		ObjectMapper mapper = new ObjectMapper();
		Map<String, Object> data = new HashMap<>();

		data.put("loader", "yara");

		if (input.equals("")) {
			data.put("score", -1L);
			data.put("malware", "N/A");

		} else {
			Map<String, Object> msg = new HashMap<>();

			try {
				msg = mapper.readValue(input, Map.class);
			} catch (IOException e) {
				e.printStackTrace();
			}

			List<Map<String, Object>> matches = (ArrayList) msg.get("matches");
			if (matches != null && matches.size() > 0) {
				data.put("yara_rules", matches);
                data.putAll(calculateScore(matches));
			} else {
				data.put("score", 0L);
                data.put("hits", new HashMap<String, Integer>());
				data.put("malware", "N/A");
			}
		}

		return data;
	}

    private void loadYaraConfig(){
        try {
            weights = (Map<String, Map<String, Object>>) Yaml.load(new File(YARA_WEIGHTS));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    /**
     * Calculate the sample's score based on rule matches.
     * @param matches List of matches.
     * @return A map describing the final score and # of hits
     */
    private Map<String, Object> calculateScore(List<Map<String, Object>> matches){

        Double finalScore = 0.0;

        Map<String, Object>  result = new HashMap<>();
        Map<String, Integer> hits   = new HashMap<>();
        Map<String, Integer> scores = new HashMap<>();

        List <String> severities = new ArrayList<>(Arrays.asList(HIGH_SEVERITY, MEDIUM_SEVERITY, LOW_SEVERITY));
        for (String severity : severities){
            hits.put(severity, 0);
            scores.put(severity, 0);
        }

        // Count hits for the matches
        for (Map<String, Object> match : matches){

            Map<String, Object> meta = (Map<String, Object>) match.get("meta");
            String severity = (String) meta.get("severity");

            // Update hits
            if (severity != null) {
                if (severity.equalsIgnoreCase(HIGH_SEVERITY)) {
                    hits.put(HIGH_SEVERITY, hits.get(HIGH_SEVERITY) + 1 );
                } else if (severity.equalsIgnoreCase(MEDIUM_SEVERITY)) {
                    hits.put(MEDIUM_SEVERITY, hits.get(MEDIUM_SEVERITY) + 1 );
                } else if (severity.equalsIgnoreCase(LOW_SEVERITY)) {
                    hits.put(LOW_SEVERITY, hits.get(LOW_SEVERITY) + 1 );
                }
            } else {
                // If no severity has been specified low will be applied
                hits.put(LOW_SEVERITY, hits.get(LOW_SEVERITY) + 1 );
            }
        }

        // If no rules match we can skip calculations
        if (!(hits.get(HIGH_SEVERITY) == 0 && hits.get(MEDIUM_SEVERITY) == 0 &&
                hits.get(LOW_SEVERITY) == 0)) {

            for (String severity : severities) {

                if (hits.get(severity) > (Integer) weights.get(severity).get("high_lower_threshold")) {
                    // Hits exceed the high threshold
                    scores.put(severity, (Integer) weights.get(severity).get("high_score"));
                } else if (hits.get(severity) < (Integer) weights.get(severity).get("low_upper_threshold") &&
                        hits.get(severity) > 0) {
                    // Hits are below the low threshold and bigger than 0
                    scores.put(severity, (Integer) weights.get(severity).get("low_score"));
                } else if (hits.get(severity) > 0) {
                    // Hits are not 0 and in between the two thresholds
                    scores.put(severity, (Integer) weights.get(severity).get("medium_score"));
                }
            }

            // Calculate the final score
            for (String severity : severities) {
                Double weighing = (Double) weights.get("general").get(severity);
                Integer score = scores.get(severity);
                finalScore += weighing * score.doubleValue();
            }
        }

        result.put("score", finalScore.longValue());
        result.put("hits", hits);

        return result;
    }
}
