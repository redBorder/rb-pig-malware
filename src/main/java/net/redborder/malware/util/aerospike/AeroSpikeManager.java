package net.redborder.malware.util.aerospike;

/**
 * Created by Lito on 20/7/15.
 */

import com.aerospike.client.*;
import com.aerospike.client.async.AsyncClient;
import com.aerospike.client.async.AsyncClientPolicy;
import com.aerospike.client.listener.ExistsListener;
import com.aerospike.client.policy.Policy;
import com.aerospike.client.policy.RecordExistsAction;
import com.aerospike.client.policy.WritePolicy;

import org.ho.yaml.Yaml;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;

public class AeroSpikeManager {
    private static final Logger log = LoggerFactory.getLogger(AeroSpikeManager.class);
    final String AEROSPIKE_CONFIG_FILE = "aerospike.yml";
    final String WEIGHT_LIST_FILE = "weight.yml";
    Map<String, Integer> weights = new HashMap<>();

    AsyncClient client;
    List<String> hosts;
    Integer timeout;
    WritePolicy writePolicy;
    private static AeroSpikeManager theInstance = null;

    public static AeroSpikeManager getInstance() {
        if (theInstance == null) {
            theInstance = new AeroSpikeManager();
        }
        return theInstance;
    }

    public AeroSpikeManager() {
        Map<String, Object> aeroSpikeConfig = loadAeroSpikeConfig();
        this.hosts = (List<String>) aeroSpikeConfig.get("servers");
        this.timeout = (Integer) aeroSpikeConfig.get("timeout");
        this.writePolicy = new WritePolicy();
        this.writePolicy.recordExistsAction = RecordExistsAction.UPDATE;
        loadWeigth();
        init();
    }

    private Map<String, Object> loadAeroSpikeConfig() {
        Map<String, Object> map = null;

        try {
            map = (Map<String, Object>) Yaml.load(new File(AEROSPIKE_CONFIG_FILE));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        Map<String, Object> general = (Map<String, Object>) map.get("general");
        return (Map<String, Object>) general.get("aerospike");
    }

    private void loadWeigth() {
        try {
            weights = (Map<String, Integer>) Yaml.load(new File(WEIGHT_LIST_FILE));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    private void init() {
        List<Host> servers = new ArrayList<>();

        for (String host : hosts) {
            String[] sp = host.split(":");
            servers.add(new Host(sp[0], Integer.parseInt(sp[1])));
        }

        AsyncClientPolicy cPolicy = new AsyncClientPolicy();
        cPolicy.timeout = timeout;

        client = new AsyncClient(cPolicy, servers.toArray(new Host[servers.size()]));
    }

    public Map<String, Object> getHash(String hash){
        Record record = get("malware", "malwareScores", hash);
        return record != null ? record.bins : new HashMap<String, Object>();
    }

    public void updateMalwareScore(String hash, String scoreName, Long score) {
        Record record = get("malware", "malwareScores", hash);
        Long totalScore = 0L;

        if (record != null) {
            Map<String, Object> scores = record.bins;

            for (Map.Entry<String, Object> entry : scores.entrySet()) {
                if(!entry.getKey().equals("hash")) {
                    Long localScore = (Long) entry.getValue();
                    Long weight = weights.get(entry.getKey()) != null ? weights.get(entry.getKey()) : 0L;

                    if (localScore >= 0) {
                        totalScore += localScore * weight;
                    }
                }
            }

            put("malware", "malwareScores", hash, Arrays.asList(new String[]{"hash", scoreName, "score"}), Arrays.asList(new Object[]{hash, score, totalScore}));
        } else {
            put("malware", "malwareScores", hash, Arrays.asList(new String[]{"hash", scoreName, "score"}), Arrays.asList(new Object[]{hash, score, totalScore}));
        }
    }

    private void put(String namespace, String collection, String key, List<String> columns, List<Object> values) {
        put(namespace, collection, key, columns, values, RecordExistsAction.UPDATE);
    }

    private Record get(String namespace, String collection, String key) {
        return client.get(new Policy(), new Key(namespace, collection, key));
    }

    private void put(String namespace, String collection, String key, List<String> columns, List<Object> values, RecordExistsAction action) {
        Key asKey = new Key(namespace, collection, key);
        Bin[] bins = new Bin[columns.size()];

        WritePolicy policy = new WritePolicy();
        policy.recordExistsAction = action;

        for (int i = 0; i < columns.size(); i++) {
            bins[i] = new Bin(columns.get(i), values.get(i));
        }

        client.put(policy, asKey, bins);
    }
}