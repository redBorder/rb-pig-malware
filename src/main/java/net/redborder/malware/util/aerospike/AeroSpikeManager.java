package net.redborder.malware.util.aerospike;


import com.aerospike.client.*;
import com.aerospike.client.async.AsyncClient;
import com.aerospike.client.async.AsyncClientPolicy;
import com.aerospike.client.policy.Policy;
import com.aerospike.client.policy.RecordExistsAction;
import com.aerospike.client.policy.WritePolicy;
import com.fasterxml.jackson.databind.ObjectMapper;
import net.redborder.malware.loaders.AbstractFileDroppingLoader;
import org.ho.yaml.Yaml;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;

public class AeroSpikeManager {
    private static final Logger log = LoggerFactory.getLogger(AeroSpikeManager.class);
    final String AEROSPIKE_CONFIG_FILE = "aerospike.yml";
    final String WEIGHT_LIST_FILE = "weights.yml";
    Map<String, Double> hashWeights = new HashMap<>();
    Map<String, Double> ipWeights = new HashMap<>();
    Map<String, Double> urlWeights = new HashMap<>();

    AsyncClient client;
    List<String> hosts;
    Integer timeout;
    WritePolicy writePolicy;
    ObjectMapper objectMapper;
    private static AeroSpikeManager theInstance = null;

    public static AeroSpikeManager getInstance() {
        if (theInstance == null) {
            theInstance = new AeroSpikeManager();
        }
        return theInstance;
    }

    public AeroSpikeManager() {
        Map<String, Object> aeroSpikeConfig = loadAeroSpikeConfig();
        this.hosts = (List<String>) aeroSpikeConfig.get("servers");
        this.timeout = (Integer) aeroSpikeConfig.get("timeout");
        this.writePolicy = new WritePolicy();
        this.writePolicy.recordExistsAction = RecordExistsAction.UPDATE;
        loadWeigth();
        init();
    }

    private Map<String, Object> loadAeroSpikeConfig() {
        Map<String, Object> map = null;

        try {
            map = (Map<String, Object>) Yaml.load(new File(AEROSPIKE_CONFIG_FILE));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        Map<String, Object> general = (Map<String, Object>) map.get("general");
        return (Map<String, Object>) general.get("aerospike");
    }

    private void loadWeigth() {
        try {
            Map<String, Object> weights = (Map<String, Object>) Yaml.load(new File(WEIGHT_LIST_FILE));
            hashWeights = (Map<String, Double>) weights.get("hash");
            ipWeights = (Map<String, Double>) weights.get("ip");
            urlWeights = (Map<String, Double>) weights.get("url");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    private void init() {
        objectMapper = new ObjectMapper();
        List<Host> servers = new ArrayList<>();

        for (String host : hosts) {
            String[] sp = host.split(":");
            servers.add(new Host(sp[0], Integer.parseInt(sp[1])));
        }

        AsyncClientPolicy cPolicy = new AsyncClientPolicy();
        cPolicy.timeout = timeout;

        client = new AsyncClient(cPolicy, servers.toArray(new Host[servers.size()]));
    }

    public Map<String, Object> getHash(String hash) {
        Record record = get("malware", "hashScores", hash);
        return record != null ? record.bins : new HashMap<String, Object>();
    }
    public Map<String, Object> getHashfromControlFiles(String hash) {
        Record record = get("malware", "controlFiles", hash);
        return record != null ? record.bins : new HashMap<String, Object>();
    }

    public Double getHashWeight(String scoreName) {
        return hashWeights.get(scoreName);
    }

    public Map<String, Object> updateMalwareHashScore(String hash, String loaderScoreName, Long loaderScore, AbstractFileDroppingLoader.LoaderType loaderType) {
        Record record = get("malware", "hashScores", hash);
        String sectionScoreName = "g_" + loaderType.value + "_score";
        String globalScoreName = "score";

        Long globalScore = 0L;
        Long sectionScore = 0L;

        Map<String, Object> malwareScores = new HashMap<>();

        if (record != null) {
            Map<String, Object> scores = record.bins;
            malwareScores.putAll(scores);
            malwareScores.put(loaderScoreName, loaderScore);
        } else {
            malwareScores.put(loaderScoreName, loaderScore);
        }

        System.out.println("HASH: " + hash);
        System.out.println("-------------------------");

        // Compute section score.
        for (Map.Entry<String, Object> entry : malwareScores.entrySet()) {
            if (entry.getKey().startsWith(loaderType.value) && !entry.getKey().contains("score")) {
                Long localScore = (Long) entry.getValue();
                Double weight = hashWeights.get(entry.getKey()) != null ? hashWeights.get(entry.getKey()) : 0.00;
                System.out.println("  - " + entry.getKey() + ": " + localScore + " * " + weight + " = " + (localScore * weight));
                if (localScore >= 0) {
                    sectionScore += Double.valueOf(localScore * weight).longValue();
                }
            }
        }

        System.out.println("  - " + sectionScoreName + ": " + sectionScore);
        System.out.println("-------------------------");

        // Compute global score
        malwareScores.put(sectionScoreName, sectionScore);

        for (Map.Entry<String, Object> entry : malwareScores.entrySet()) {
            if (entry.getKey().startsWith("g") && entry.getKey().contains("score")) {
                Long localScore = (Long) entry.getValue();
                Double weight = hashWeights.get(entry.getKey()) != null ? hashWeights.get(entry.getKey()) : 0.00;
                System.out.println("  - " + entry.getKey() + ": " + localScore + " * " + weight + " = " + (localScore * weight));
                if (localScore >= 0) {
                    globalScore += Double.valueOf(localScore * weight).longValue();
                }
            }
        }

        System.out.println("  - " + globalScoreName + ": " + globalScore);
        System.out.println("-------------------------");
        // Update score
        malwareScores.put(globalScoreName, globalScore);

        System.out.println("UPDATE: ");
        System.out.println("  * " + globalScoreName + ": " + globalScore);
        System.out.println("  * " + sectionScoreName + ": " + sectionScore);
        System.out.println("  * " + loaderScoreName + ": " + loaderScore);

        System.out.println("-------------------------");

        String listType = (String) malwareScores.get("list_type");

        if (listType == null) {
            listType = "none";
        }

        put("malware", "hashScores", hash,
                Arrays.asList("hash", globalScoreName, sectionScoreName, loaderScoreName, "list_type"),
                Arrays.asList(new Object[]{hash, globalScore, sectionScore, loaderScore, listType}));

        malwareScores.remove("hash");

        if (listType.equals("black")) {
            for (String key : hashWeights.keySet()) {
                malwareScores.put(key, 100L);
            }
        } else if (listType.equals("white")) {
            for (String key : hashWeights.keySet()) {
                malwareScores.put(key, 0L);
            }
        }

        return malwareScores;
    }

    public void updateDataLocation(String hash, String time) {

        Key key = new Key("malware", "controlFiles", hash);

        String binName = "time";

        Record record = null;

        try{
            record = client.get(new Policy(), key, binName);
        }catch (AerospikeException e){
            System.out.println("Bin does not exist");
        }

        List<String> timeList = new LinkedList<>();

        if (record != null && record.bins != null){

            timeList = (List<String>) record.getList(binName);

            if(timeList.contains("rt") && !time.equals("rt") && !timeList.contains(time)){
                timeList.remove("rt");
                timeList.add(time);
            }else if(!timeList.contains("rt") && time.equals("rt") || !timeList.contains(time)){
                timeList.add(time);
            }

        }else
            timeList.add(time);

        client.put(writePolicy, key, new Bin(binName, timeList));

    }

    public void updateFuzzyStatus(String hash) {
        List <Object> fuzzy = new ArrayList<>();
        List <String> column = new ArrayList<>();
        column.add("hash");
        column.add("fuzzy");
        fuzzy.add(hash);
        fuzzy.add(1);
        put("malware", "controlFiles", hash, column,
                fuzzy);
    }

    private void put(String namespace, String collection, String key, List<String> columns, List<Object> values) {
        put(namespace, collection, key, columns, values, RecordExistsAction.UPDATE);
    }

    private Record get(String namespace, String collection, String key) {
        return client.get(new Policy(), new Key(namespace, collection, key));
    }

    private void put(String namespace, String collection, String key, List<String> columns, List<Object> values, RecordExistsAction action) {
        Key asKey = new Key(namespace, collection, key);
        Bin[] bins = new Bin[columns.size()];

        WritePolicy policy = new WritePolicy();
        policy.recordExistsAction = action;

        for (int i = 0; i < columns.size(); i++) {
            bins[i] = new Bin(columns.get(i), values.get(i));
        }

        client.put(policy, asKey, bins);
    }

    public boolean checkControlFilesStatus(String hash, String bin) {
        Record entry = get("malware", "controlFiles", hash);
        boolean exists;

        if (entry != null) {
            Object value = entry.getValue(bin);
            if (value != null) {
                exists = (long) value != 0;
            } else {
                exists = false;
            }
        } else {
            exists = false;
        }

        return exists;
    }

    public void setControlFile(String hash, String bin, Long value) {
        put("malware", "controlFiles", hash, Arrays.asList("hash", bin), Arrays.<Object>asList(hash, value));
    }

    public void close() {
        client.close();
    }
}